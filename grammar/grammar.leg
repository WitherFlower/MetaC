%{

#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "objects.h"

#define YYSTYPE oop

#define YY_MALLOC(C, N)        GC_malloc(N)
#define YY_REALLOC(C, P, N)    GC_realloc(P, N)
#define YY_FREE(C, P)        GC_free(P)

%}

grammar =       - r:root
                ( declaration
                | d:definition { Object_push(r, d); } 
                )+
                trailer? end-of-file
                { printTree(r); }
                

root = { $$ = newGrammar(); }

declaration =   '%{' < ( !'%}' . )* > RPERCENT

trailer =       '%%' < .* >

definition =    i:identifier ASSIGN e:expression SEMI?          { $$ = newDefinition(i, e); }

expression =    s1:sequence (
                    BAR s2:sequence                             { s1 = newAlternation(s1, s2); } 
                )*                                              { $$ = s1; }

# Was error+ before, rewritten for reasons
sequence =      e:error (
                    f:error                                     { e = newSequence(e, f); }
                )*                                              { $$ = e; }

error =         p:prefix ( TILDE action )?                      { $$ = p; }

prefix =        AND action
                |
                ( AND s:suffix                                  { $$ = newAnd(s); }
                | NOT s:suffix                                  { $$ = newNot(s); }
                | s:suffix                                      { $$ = s; }
                )

suffix =        p:primary
                ( QUERY                                         { p = newOptional(p); }
                | STAR                                          { p = newStar(p); }
                | PLUS                                          { p = newPlus(p); }
                )?                                              { $$ = p; }

primary =       i1:identifier COLON i2:ruleCallIdent !ASSIGN    { $$ = newAssignment(i1, i2); }
|               i:ruleCallIdent !ASSIGN                         { $$ = i; }
|               LPAREN e:expression RPAREN                      { $$ = e; }
|               l:literal                                       { $$ = l; }
|               c:class                                         { $$ = c; }
|               DOT                                             { $$ = newDot(); }
|               a:action                                        { $$ = a; }
|               BEGIN                                           { $$ = newBegin(); }
|               END                                             { $$ = newEnd(); }

identifier =    < [-a-zA-Z_][-a-zA-Z_0-9]* > -                  { $$ = newStringEscaped(yytext); }

ruleCallIdent = < [-a-zA-Z_][-a-zA-Z_0-9]* > -                  { $$ = newIdentifier(yytext); }

literal =       ['] < ( !['] char )* > ['] -                    { $$ = newStringEscaped(yytext); }
|               ["] < ( !["] char )* > ["] -                    { $$ = newStringEscaped(yytext); }

class =         '[' < ( !']' range )* > ']' -                   { $$ = newCharacterClass(yytext); }

range =         char '-' char | char

char =          '\\' [abefnrtv'"\[\]\\]
|               '\\' [0-3][0-7][0-7]
|               '\\' [0-7][0-7]?
|               !'\\' .

action =        m:metaBlock -                           { $$ = newAction(m); }

# braces =        '{' braces* '}'
# |               !'}' .

- =             ( space | comment )*
space =         ' ' | '\t' | end-of-line
comment =       '#' ( !end-of-line . )* end-of-line
end-of-line =   '\r\n' | '\n' | '\r'
end-of-file =   !.

### Meta language grammar

metaStatement   = # WHILE LPAREN c:expr RPAREN s:metaStatement      { $$ = newWhile(c, s) }
                # | IF LPAREN c:expr RPAREN s:metaStatement
                #   ( ELSE t:metaStatement                          { $$ = newIf(c, s, t  ) }
                #   |                                               { $$ = newIf(c, s, nil) }
                #   )
                  b:metaBlock                                       { $$ = newBlock(b); }
                | e:metaExpression SEMI                             { $$ = e; }
#
metaExpression  = p:metaPrimary
                ( DOT   i:metaId               ASSIGN e:metaExpression  # { $$ = newSetProp(p, i, e) }
                | LBRAK i:metaExpression RBRAK ASSIGN e:metaExpression  # { $$ = newSetArray(p, i, e) }
                )
                | (i:metaId | i:retval)        ASSIGN e:metaExpression  { $$ = newSetVar(i, e); }
                | pf:metaPostfix                                        { $$ = pf; }
#     | logor

# logor    = l:logand ( BARBAR r:logand        { l = newBinop(opLogOr,  l, r) }
#            )*                { $$ = l }
#
# logand    = l:bitor ( ANDAND r:bitor        { l = newBinop(opLogAnd, l, r) }
#           )*                { $$ = l }
#
# bitor    = l:bitxor ( OR r:bitxor        { l = newBinop(opBitOr,  l, r) }
#            )*                { $$ = l }
#
# bitxor    = l:bitand ( XOR r:bitand        { l = newBinop(opBitXor, l, r) }
#            )*                { $$ = l }
#
# bitand    = l:eq ( AND r:eq            { l = newBinop(opBitAnd, l, r) }
#            )*                { $$ = l }
#
# eq    = l:ineq ( EQ    r:ineq            { l = newBinop(opEq,    l, r) }
#            | NOTEQ r:ineq            { l = newBinop(opNotEq, l, r) }
#            )*                { $$ = l }
#
# ineq    = l:shift ( LESS   r:shift        { l = newBinop(opLess,   l, r) }
#             | LESSEQ r:shift        { l = newBinop(opLessEq, l, r) }
#             | GRTREQ r:shift        { l = newBinop(opGrtrEq, l, r) }
#             | GRTR   r:shift        { l = newBinop(opGrtr,   l, r) }
#             )*                { $$ = l }
#
# shift    = l:sum ( SHL r:sum            { l = newBinop(opShl, l, r) }
#           | SHR r:sum            { l = newBinop(opShr, l, r) }
#           )*                { $$ = l }
#
# sum    = l:prod ( PLUS  r:prod            { l = newBinop(opAdd, l, r) }
#            | MINUS r:prod            { l = newBinop(opSub, l, r) }
#            )*                { $$ = l }
#
# prod    = l:postfix ( STAR  r:postfix        { l = newBinop(opMul, l, r) }
#               | SLASH r:postfix        { l = newBinop(opDiv, l, r) }
#               | PCENT r:postfix        { l = newBinop(opMod, l, r) }
#               )*                { $$ = l }

metaPostfix = p:metaPrimary
            ( 
            # LBRAK e:metaExpression RBRAK  !ASSIGN     { p = newGetArray(p, e) }
            # DOT   i:metaId         a:args !ASSIGN     { p = newInvoke(p, i, a) }
            # DOT   i:metaId                !ASSIGN     { p = newGetProp(p, i) }
                                     a:args !ASSIGN     { p = newCall(p, a); }
            )*                                          { $$ = p; }

args        = LPAREN a:mklist
            ( 
                ( k:metaId COLON e:metaExpression       { Object_put(a, k, e); }
                    | e:metaExpression                  { Object_push(a, e); }
                )
                ( COMMA 
                    ( k:metaId COLON e:metaExpression   { Object_put(a, k, e); }
                        | e:metaExpression              { Object_push(a, e); }
                    ) 
                )* 
            )? RPAREN        { $$ = a; }

# params    = LPAREN p:mklist
#       ( i:id                { Object_push(p, i); }
#             ( COMMA i:id             { Object_push(p, i); }
#         )* )? RPAREN            { $$ = p; }

mklist      =                                   { $$ = new(pObject); }

# metaPrimary = nil | number | string | symbol | var | lambda | subexpr
metaPrimary = nil | metaVar | metaSubExpr

# lambda    = p:params b:block                { $$ = newLambda(p, b); }

metaSubExpr = LPAREN e:metaExpression RPAREN    { $$ = e; }

metaBlock   =  LBRACE b:mklist
            (  e:metaStatement                  { Object_push(b, e); }
            )* RBRACE                           { $$ = b; }

nil         = NIL                               { $$ = nil; }
retval      = RETVAL                            { $$ = newReturnValue(); }

# number    = "-" u:unsign                { $$ = neg(u); }
#     | "+" n:number                { $$ = u; }
#     |     u:unsign                { $$ = u; }
#
# unsign    = < DIGIT+ '.' DIGIT* EXP? > -        { $$ = newFloat(strtod(yytext, 0)); }
#     | < DIGIT* '.' DIGIT+ EXP? > -        { $$ = newFloat(strtod(yytext, 0)); }
#     | "0" [bB] < BIGIT+ > -            { $$ = newInteger(strtol(yytext, 0,  2)); }
#     | "0" [xX] < HIGIT+ > -            { $$ = newInteger(strtol(yytext, 0, 16)); }
#     | "0" < OIGIT* > -            { $$ = newInteger(strtol(yytext, 0,  8)); }
#     | < DIGIT+ > -                { $$ = newInteger(strtol(yytext, 0, 10)); }
#
# string    = '"' < ( !'"' . )* > '"' -        { $$ = newStringEscaped(yytext); }
#     | "'" < ( !"'" . )* > "'" -        { $$ = newStringEscaped(yytext); }
#
# symbol    = HASH i:id                { $$ = i; }

metaVar     = i:metaId                      { $$ = newGetVar(i); }

metaId      = < LETTER ALNUM* > -           { $$ = intern(yytext); }

# BIGIT    = [0-1]
# OIGIT    = [0-7]
DIGIT    = [0-9]
# HIGIT    = [0-9A-Fa-f]
LETTER    = [A-Za-z_]
ALNUM    = LETTER | DIGIT
# SIGN    = [-+]
# EXP    = [eE] SIGN DIGIT+
#
# -    = SPACE*
#
# SPACE    = [ \t\n\r] | '//' (!EOL .)*
# EOL    = [\n\r]

BAR =           '|' -
NOT =           '!' -
QUERY =         '?' -
BEGIN =         '<' -
END =           '>' -
TILDE =         '~' -
RPERCENT =      '%}' -

NIL    = "nil"   !ALNUM  -
# WHILE    = "while" !ALNUM  -
# IF    = "if"    !ALNUM  -
# ELSE    = "else"  !ALNUM  -
RETVAL = "$$" -

# HASH    = "#"          -
SEMI    = ";"          -
ASSIGN    = "="  ![=]     -
COMMA    = ","          -
COLON    = ":"          -
LPAREN    = "("         -
RPAREN    = ")"         -
LBRAK    = "["         -
RBRAK    = "]"         -
LBRACE    = "{"         -
RBRACE    = "}"         -
# BARBAR  = "||" ![=]    -
# ANDAND  = "&&" ![=]    -
# OR    = "|"  ![|=]    -
# XOR    = "^"  ![=]    -
AND    = "&"  ![&=]    -
# EQ    = "=="             -
# NOTEQ    = "!="             -
# LESS    = "<"  ![<=]       -
# LESSEQ  = "<="       -
# GRTREQ  = ">="       -
# GRTR    = ">"  ![=]     -
# SHL    = "<<" ![=]       -
# SHR    = ">>" ![=]       -
PLUS    = "+"  ![+=]       -
# MINUS    = "-"  ![-=]    -
STAR    = "*"  ![=]     -
# SLASH    = "/"  ![/=]    -
# PCENT    = "%"  ![*=]    -
DOT    = "."             -

# EQUAL    = "=="       -
# PLING    = "!"         -
# AND    = "&"         -
# COLON    = ":"         -
# PLUS    = "+"         -
# STAR    = "*"         -
# QUERY    = "?"         -
# BAR    = "|"         -
# LANGLE    = "<" -
# RANGLE    = ">" -
%%

int main()
{
    initPrototypeSystem();
    while (yyparse());

    return 0;
}

