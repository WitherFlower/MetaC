%{

#include <stdio.h>
#include <string.h>

#include "grammar_objects.h"

#define YYSTYPE oop

%}

grammar =       - r:root
               ( declaration | d:definition { addRuleDefinitionToGrammar(r, d); } )+
               trailer? end-of-file
               { printTree(r); }

root = { $$ = newGrammar(); }

declaration =   '%{' < ( !'%}' . )* > RPERCENT

trailer =       '%%' < .* >

definition =    i:identifier EQUAL e:expression SEMICOLON?      { $$ = newBinary(Definition, i, e); }

expression =    s1:sequence (
                    BAR s2:sequence                             { s1 = newBinary(Alternation, s1, s2); } 
                )*                                              { $$ = s1; }

# Was error+ before, rewritten for reasons
sequence =      e:error (
                    f:error                                     { e = newBinary(Sequence, e, f); }
                )*                                              { $$ = e; }

error =         p:prefix ( TILDE action )?                      { $$ = p; }

prefix =        AND action
                |
                ( a:AND                                         
                | n:NOT                                         
                )? s:suffix                                     {
                                                                    if (a)      { $$ = newUnary(And, s); }
                                                                    else if (n) { $$ = newUnary(Not, s); }
                                                                    else        { $$ = s; }
                                                                }

suffix =        p:primary
                ( QUERY                                         { p = newUnary(Optional, p); }
                | STAR                                          { p = newUnary(Star, p); }
                | PLUS                                          { p = newUnary(Plus, p); }
                )?                                              { $$ = p; }

primary =       i1:identifier COLON i2:identifier !EQUAL        { $$ = newBinary(Assignment, i1, i2) }
|               i:identifier !EQUAL                             { $$ = i; }
|               OPEN e:expression CLOSE                         { $$ = e; }
|               l:literal                                       { $$ = l; }
|               c:class                                         { $$ = c; }
|               DOT                                             { $$ = newDot(); }
|               a:action                                        { $$ = a; }
|               BEGIN
|               END

identifier =    < [-a-zA-Z_][-a-zA-Z_0-9]* > -                  { $$ = newIdentifier(yytext); }

literal =       ['] < ( !['] char )* > ['] -                    { $$ = newString(yytext); }
|               ["] < ( !["] char )* > ["] -

class =         '[' < ( !']' range )* > ']' -                   { $$ = newCharacterClass(yytext); }

range =         char '-' char | char

char =          '\\' [abefnrtv'"\[\]\\]
|               '\\' [0-3][0-7][0-7]
|               '\\' [0-7][0-7]?
|               !'\\' .

action =        '{' < braces* > '}' -                           { $$ = newAction(yytext); }

braces =        '{' braces* '}'
|               !'}' .

EQUAL =         '=' -
COLON =         ':' -
SEMICOLON =     ';' -
BAR =           '|' -
AND =           '&' -
NOT =           '!' -
QUERY =         '?' -
STAR =          '*' -
PLUS =          '+' -
OPEN =          '(' -
CLOSE =         ')' -
DOT =           '.' -
BEGIN =         '<' -
END =           '>' -
TILDE =         '~' -
RPERCENT =      '%}' -

- =             ( space | comment )*
space =         ' ' | '\t' | end-of-line
comment =       '#' ( !end-of-line . )* end-of-line
end-of-line =   '\r\n' | '\n' | '\r'
end-of-file =   !.

%%

int main()
{
    while (yyparse());

    return 0;
}

