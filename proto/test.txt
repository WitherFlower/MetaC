// nil is the undefined object
// integers, floats, strings are as usual
// #<identifier> is a symbol literal

print(nil, " ", 42, " ", 3.14, " string ", #Symbol, " newline \n");

// the prototypical object types used in the implementation have global names
// e.g., Object is the prototypical object at the root of the delegation hierarchy

print("Object  => ", Object,  "\n");  // this prints as <Object>
print("Lambda  => ", Lambda,  "\n");  // this prints as <Lambda>
print("Closure => ", Closure, "\n");  // this prints as <Closure>

// create a new object instance by asking an existing one to be the delegate for a new instance
// e.g., to create a new object that delegates to the prototype Object...

o = Object.new();

print("o = Object.new() => ", o, "\n");

// this prints as <<Object>> because the number of <> surrounding the name tells you
// how many levels of delegation were needed before the __name__ property was found

// arguments can be positional and/or key:value pairs
// for the new() method, the arguments become the properties of the newly created object

o = Object.new(foo: 42, bar: 666);

print("o = Object.new(foo:42, bar: 666) => ", o, "\n", full: 1);
print("o.foo => ", o.foo, "\n");

// to create a new type make a prototype with a __name__ that delegates to another prototype

Point = Object.new(__name__: #Point);

// objects can be created from the new prototype because it delegates to the Object prototype,
// in other words the new prototype 'inherits' Object.new()

// objects created from the new prototype will inherit its __name__ property

print("Point.new()           => ", Point.new(),           "\n");
print("Point.new(x: 3, y: 4) => ", Point.new(x: 3, y: 4), "\n", full: 1);

// anonymous functions are written: "(parameters...) { statements... }"
// all statements return values
// the last statement implicitly provides a return value for the entire function

double = (x) { x+x; };

print("twice 21 is ", double(21), "\n");

// use the keyword argument "full:x" (where x is non-nil) to make the print primitive
// recursively print the entire contents of any objects it encounters

print("double => ", double, "\n", full:1);

// anonymous functions installed as properties of a prototype become methods
// for all objects that delegate to the prototype

Point.magnitude = () { sqrt(self.x * self.x + self.y * self.y); };

m = Point.new(x: 3, y: 4).magnitude();

print("Point.new(x:3, y:4).magnitude() => ", m, "\n");

// functions close over their dynamic environment when created
// (yes, I know, something needs to be done about all the nasty semicolons)

makeCounter = (n)
{
  n = n - 1;          // make the counter return n the first time it is called
  () { print(__env__(), "\n", full:1);  n = n + 1; };  // the counter is an anonymous function, closing over n, that increments n
};

counter = makeCounter(40);

print(counter(), "\n");
print(counter(), "\n");
print(counter(), "\n");
print(counter(), "\n");

test = (x) { print(x, " "); if (x) print("yes\n"); else print("no\n"); };

test(nil);
test(1);
test("hello");

nfib = (n) { if (n < 2) 1; else nfib(n-1) + nfib(n-2) + 1; };

print(nfib(5), "\n");
print(nfib(15), "\n");

tf = (n) { if (n) print(1); else print(0); };

tf(0 <  1);  tf(1 <  1);  tf(2 <  1);  print("\n");
tf(0 <= 1);  tf(1 <= 1);  tf(2 <= 1);  print("\n");
tf(0 >= 1);  tf(1 >= 1);  tf(2 >= 1);  print("\n");
tf(0 >  1);  tf(1 >  1);  tf(2 >  1);  print("\n");

tf(0 == 1);  tf(1 == 1);  tf(2 == 1);  print("\n");
tf(0 != 1);  tf(1 != 1);  tf(2 != 1);  print("\n");

print(16 << 0); print(16 << 1); print(16 << 2); print(16 << 3); print("\n");
print(16 >> 0); print(16 >> 1); print(16 >> 2); print(16 >> 3); print("\n");

print(0b101010, " ");
print(052, " ");
print(42, " ");
print(0x2a, "\n");

bin__ = (n, b, w) {
  if (n >= 2 || w > 1) bin__(truncate(n / 2), b, w - 1);
  print(n % 2);
};

bin = (n) {
  b = Object.new();
  bin__(n, b, 4);
//  while (b.length() > 0) print(b.pop());
  print("\n");
};

bin(42);

bin(0b1110 | 0b0111);
bin(0b1110 ^ 0b0111);
bin(0b1110 & 0b0111);

t = () { print("t");  1; };
f = () { print("f");  nil; };

print("f||f "); print(f() || f(), "\n");
print("f||t "); print(f() || t(), "\n");
print("t||f "); print(t() || f(), "\n");
print("t||t "); print(t() || t(), "\n");

print("f&&f "); print(f() && f(), "\n");
print("f&&t "); print(f() && t(), "\n");
print("t&&f "); print(t() && f(), "\n");
print("t&&t "); print(t() && t(), "\n");

1   || print("fail\n");
nil && print("fail\n");
nil || print("ok\n");
1   && print("ok\n");

